[{"title":"单例模式_02.破坏及防御","date":"2022-03-30T09:10:00.000Z","url":"/2022/03/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F_02.%E7%A0%B4%E5%9D%8F%E5%8F%8A%E9%98%B2%E5%BE%A1/","tags":[["设计模式笔记","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"],["创建型模式","/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"],["单例模式","/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"]],"categories":[["undefined",""]],"content":"前言上一篇介绍了单例模式的几种实现，基本可以放在实际开发中使用，但其实有些边界没有被考虑，从而无法保证单例模式的鲁棒性。 介绍几种破坏的方法和对应防御所谓的边界，其实就是那些可以突破单例模式限制，创建多个实例的操作。其实我们已经在第一篇的懒加载实现中介绍过几个。此篇将着重讨论几种破坏单例模式的方式以及防御方式。 反射在第一篇中我们了解到，单例模式下类的构造方法是需要私有化的，避免外部通过 new 创建实例。但我们忽略了Java有反射这种很开挂的特性。我们以饿汉式为例，准备一个测试方法如下: 运行后得到的测试结果为: 就像是三体中人类举全球力量打造的2000多战舰被三体的一个水滴轻松打败，反射真的是Java中开挂的存在。为了防止这个挂，我们可以对Singleton的构造方法加以强化。 再次执行测试方法，就会得到这样的结果: 当通过反射去强行调用构造器时就会在构造中报错，无法完成实例化。 反序列化多数情况下，我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时将其进行反序列化。关于序列化可以参考《序列化理解起来很简单》。这其实也是对单例的保持有破坏的风险。我们通过一个测试方法观察下: 执行得到结果: 此时，代码中将流反序列化为对象的操作，已经破坏了单例模式。所以在涉及到序列化的场景时，要格外注意对单例的破坏。为了保持单例，需要在Singleton中定义readResolve: 再次执行单元测试，得到下面的结果: 前文说到”定义readResolve”,在开始接触单例的资料前确实很迷惑。平时我们接触到的这些不知道从哪儿突然冒出来的吾称为”约定的方法”,都是进行重写。而在这个场景下，Singleton唯一实现的Serializable接口是没有方法的。那为什么说是定义这个方法呢？我们可以单元测试中反序列化操作，即ObjectInputStream的对象执行readObject()方法作为切入点追踪下源码。当追踪到readOrdinaryObject(boolean unshared)方法时，如图所示: 方法体中出现了两个调用:desc.hasReadResolveMethod()和desc.invokeReadResolve(obj)理解为对目标流进行检查是否有readResolve()这个方法，如果有就调用。所以在这里说是”定义“其实是比较准确的，一些资料中写”重写readResolve“，个人认为欠妥(支撑这个观点的一个论据是在readResolve方法上显式地加@Override，编译器是会报错的)。 clone还有一种方式可以破坏单例模式，就是通过对象拷贝。需要实现一个Cloneable接口，如果要调用拷贝，需要显式地在Singleton中重写Object类的clone()方法: 这个对于想实现单例的开发者就很吊诡。既要单例，又要做到对象拷贝。难怪大部分资料称之为主动破坏单例模式。同样，我们通过一个单元测试观察下: 执行得到结果: 那如果想防止这种破坏呢，还是可以在clone()方法中做拦截: 再次执行单元测试，就得到: 但是，谁会这么无聊，主动去开启破坏然后又拦截掉呢？这不是有病吗？ 总结这篇笔记描述了几种破坏单例的方式以及应对，首先需要注意的是上一篇中考量单例模式的第一点就是将构造器私有化，脱离了这个前提，单例形同虚设，也无需谈论什么破坏。我们可以通过强化构造器，对用反射非法实例化的方式进行拦截（本篇主要以饿汉式为例，懒汉式需要通过一个计数器，在构造器中对计数器做Double-Check，计数超过1就抛出异常拦截）。很多时候需要进行对象序列化，在后续反序列化时，也会对单例进行破坏，可以定义一个readResolve()方法,在方法体中拦截破坏。另外一种则是我们主动去实现Cloneable接口，重写Object的clone()方法，去生成另一个实例，称为开发者的”主动破坏”。到此，单例模式的介绍应该结束了。其实还有一个小细节，是我从开始一直在考虑的，即我们在拦截单例破坏时，需要抛出异常呢，还是返回我们原本的单例呢？当然两种都是可以实现的，有些资料中甚至在拦截反序列化时返回实例，在拦截clone()时抛出异常，这就很不能忍。个人观点，当然也已体现在本篇笔记的代码中，还是要保持一致，统一返回单例或者统一抛出异常，在此基础上，我更倾向于抛出异常。因为无论开发者是想通过反射、反序列化还是clone，都期望能得到新的实例。而返回单例在运行时并没有明显的错误，可能只有在业务层面看得到对象所包含的信息的差距，令开发者误解为已经成功破坏了单例。通过报错，可以在运行时提醒开发者快速了解到对于这个类存在使用不当，一定程度上是符合fail-fast原则的。emm。。他们是破坏者啊，为什么要替他们考虑。。。"},{"date":"2022-01-26T09:03:00.000Z","url":"/2022/01/26/2022-01-26/","categories":[["undefined",""]],"content":"来测试第一条说说迫于年底运营那边一堆积压的工作 设计模式就慢慢来这篇无头文章会被hexo识别为简短的小日志 形式就和其他不一样啦 早期hexo引擎需要在Front-Matter添加type: status才能实现 v5后自动将无头文章解析成如此如果v4及以下就会自动把文件名作为无头文章的title."},{"title":"单例模式_01.介绍几种实现方式","date":"2022-01-18T06:10:00.000Z","url":"/2022/01/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F_01.%E4%BB%8B%E7%BB%8D%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","tags":[["设计模式笔记","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"],["创建型模式","/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"],["单例模式","/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"]],"categories":[["undefined",""]],"content":"什么是单例模式&emsp;&emsp;单例设计模式是一种创建型的设计模式,它保证了系统中一个类只有一个实例且一般会提供全局的访问方法.这是一种在实际开发中很常见的设计模式,主要应用在频繁创建和销毁对象的场景中,通过使用单例以提升性能. 如何实现单例模式&emsp;&emsp;单例模式的实现方式有很多,其实主要是需要考量以下几点: 考虑避免外部通过 new 创建实例(构造器私有化); 考虑对象创建时的线程安全问题; 考虑是否支持延迟加载(lazy loading,或load on demand); 考虑 getInstance() 性能是否高(是否加锁); &emsp;&emsp;以下是几种通过Java实现的单例模式: 饿汉式 &emsp;&emsp;饿汉式实现是在类加载的时候,instance静态实例就已经创建并且初始化好了,创建的过程是线程安全的,在实际使用时提供一个全局的方法快速返回这个实例. &emsp;&emsp;不过,这种方式并不支持延迟加载,意味着提前占用内存资源.部分的资料都并不推荐这种做法: 实例占用资源多(比如占用内存多)或初始化耗时长(比如需要加载各种配置文件),提前初始化实例是一种浪费资源的行为.最好的方法应该在用到的时候再去初始化. 另一种观点是: 1)如果初始化耗时长,用它的时候才去执行这个耗时长的初始化过程会影响系统性能.将耗时的初始化操作,提前到程序启动的时候能避免在程序运行时再去初始化导致的性能问题.2)按照 fail-fast 的设计原则,实例占用资源过多,也应该提早加载,如果有问题也能及早暴露,及早修复. 前一种观点考虑的是资源是否被有效利用,第二种则是通过系统性能以及 fail-fast 原则去考虑.在实际开发时个人觉得应该结合信息系统部署环境以及建立目的考虑,如果是一个资源紧缺型系统或者对响应没有十分高的要求,则饿汉式的单例模式不适合使用.如果不是一个资源有限的系统,并且对响应性能有一定的要求,则饿汉式也是一种可以考虑的创建方式. 懒汉式 这种方式支持延迟加载,但仅实现了单线程下的单例.多线程情况下,当一个线程正好在if (null != instance)为true判断完成时时间片用完.另一个线程同样进到这个判断,因为instance还没有实例,所以创建并返回了实例,等到第一个线程继续执行时就会再次创建新的实例.如何解决呢?可以将getInstance()改为同步方法: 这样就实现了在多线程并发情况下的单例,但随之也带来效率问题.每个线程在执行getInstance()时都需要进行同步,而实例化代码实际只需要执行一次,后续的调用只需要return instance就可以了.所以这是一种低效的创建方式,实际开发并不推荐使用.那是否可以通过同步代码块缩小同步的粒度呢?比如: 我们看到是在判断instance为空后加锁，其实并没有解决多线程下单例的问题.所以上面的实现是有问题的,那怎么修改呐? 双重检测 只需要在同步代码块中执行时再加一个instance为空的判断就能保证即使多个线程进入,只会有一个线程创建实例。而创建完成之后,其他线程再次调用getInstance(),并不会进入同步块中,直接return instance。妙哉!这种进行2次判断的方式,称为Double-Check.由懒汉式变化而来,所以支持lazy loading,加锁保证线程安全的同时，在响应性能上也很高效.推荐在开发中使用. 静态内部类&emsp;&emsp;再看一种比较简洁的实现 又是一种优雅的实现,真·没有浪费一句话.我们观察下代码,形似饿汉式. 但其实它又能做到延迟加载,当Singleton类被加载的时候,并不会创建SingletonHolder实例化对象,而是在首次调用getInstance()时被加载,且实例化INSTANCE.详见Java 静态内部类的加载时机.并且实例创建过程由JVM保证其线程安全性及唯一性,又不用上锁,所以性能也很好.是非常推荐的一种单例实现. 枚举 这种实现方式通过Java枚举类型本身的特性(since JDK 1.5),保证了实例创建的线程安全性和实例的唯一性,并且还能防止通过反序列化破坏单例模式.Joshua J. Bloch在Effective Java(Enforce the singleton property with a private constructor or an enum type))中提倡使用这种方式. 总结本篇简单介绍了单例模式以及单例模式的几种Java实现.可用的实现有饿汉式,双重检测,静态内部类以及枚举.其中静态内部类和枚举是个人认为比较优雅的实现方式.如果确定此类一定会被使用,可以选择饿汉式,枚举.如果需要一定条件才被使用,可以选用支持懒加载的几种实现.当然也要视具体情况而定对吧(废话),比如虽然我不确定会不会被使用,但实例化此类需要耗费很长的时间,然后你或者用户又是一个性能强迫症患者,那当然选择饿汉式或者枚举啦."},{"title":"初始台地","date":"2020-04-16T08:01:09.000Z","url":"/2020/04/16/%E5%88%9D%E5%A7%8B%E5%8F%B0%E5%9C%B0/","categories":[["undefined",""]],"content":"Ciao World! "},{"title":"以往归档","date":"2020-04-15T16:00:00.000Z","url":"/2020/04/15/%E4%BB%A5%E5%BE%80%E5%BD%92%E6%A1%A3/","categories":[["undefined",""]],"content":"转markdown好累 "}]